import type { SqlitePlugin, Value } from '@capawesome-team/capacitor-sqlite';
import type { DrizzleConfig } from 'drizzle-orm';
import { drizzle as drizzleProxy } from 'drizzle-orm/sqlite-proxy';
import type { SqliteRemoteDatabase } from 'drizzle-orm/sqlite-proxy';

export type { SqliteRemoteDatabase } from 'drizzle-orm/sqlite-proxy';

export interface CapawesomeDrizzleConfig<
  TSchema extends Record<string, unknown> = Record<string, never>,
> extends DrizzleConfig<TSchema> {
  /**
   * The unique identifier for the database returned by `Sqlite.open()`.
   */
  databaseId: string;
}

/**
 * Bundled migrations object generated by `drizzle-kit generate`.
 *
 * Set `dialect: 'sqlite'` and `driver: 'expo'` in your `drizzle.config.ts`
 * to generate this format.
 */
export interface Migrations {
  journal: {
    entries: {
      idx: number;
      when: number;
      tag: string;
      breakpoints: boolean;
    }[];
  };
  migrations: Record<string, string>;
}

/**
 * Create a Drizzle ORM instance backed by `@capawesome-team/capacitor-sqlite`.
 *
 * @example
 * ```typescript
 * import { Sqlite } from '@capawesome-team/capacitor-sqlite';
 * import { drizzle } from '@capawesome/capacitor-sqlite-drizzle';
 *
 * const { databaseId } = await Sqlite.open({ path: 'my.db' });
 * const db = drizzle(Sqlite, { databaseId });
 * ```
 */
export function drizzle<
  TSchema extends Record<string, unknown> = Record<string, never>,
>(
  client: SqlitePlugin,
  config: CapawesomeDrizzleConfig<TSchema>,
): SqliteRemoteDatabase<TSchema> {
  const { databaseId, ...drizzleConfig } = config;

  const callback = async (
    sql: string,
    params: unknown[],
    method: 'run' | 'all' | 'values' | 'get',
  ): Promise<{ rows: unknown[] }> => {
    return executeQuery(client, databaseId, sql, params, method);
  };

  const batchCallback = async (
    batch: {
      sql: string;
      params: unknown[];
      method: 'run' | 'all' | 'values' | 'get';
    }[],
  ): Promise<{ rows: unknown[] }[]> => {
    const results: { rows: unknown[] }[] = [];
    for (const query of batch) {
      results.push(
        await executeQuery(
          client,
          databaseId,
          query.sql,
          query.params,
          query.method,
        ),
      );
    }
    return results;
  };

  return drizzleProxy(callback, batchCallback, drizzleConfig);
}

/**
 * Run pending migrations against the database.
 *
 * Accepts the bundled migrations object generated by `drizzle-kit generate`
 * with `dialect: 'sqlite'` and `driver: 'expo'` in your `drizzle.config.ts`.
 *
 * Tracks applied migrations by timestamp in a `__drizzle_migrations` table,
 * matching the official Drizzle migration format.
 *
 * @example
 * ```typescript
 * import { Sqlite } from '@capawesome-team/capacitor-sqlite';
 * import { drizzle, migrate } from '@capawesome/capacitor-sqlite-drizzle';
 * import migrations from './drizzle/migrations';
 *
 * const { databaseId } = await Sqlite.open({ path: 'my.db' });
 * const db = drizzle(Sqlite, { databaseId });
 *
 * await migrate(Sqlite, databaseId, migrations);
 * ```
 */
export async function migrate(
  client: SqlitePlugin,
  databaseId: string,
  migrations: Migrations,
): Promise<void> {
  const migrationEntries = readMigrationFiles(migrations);

  await client.execute({
    databaseId,
    statement: `CREATE TABLE IF NOT EXISTS __drizzle_migrations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      hash TEXT NOT NULL,
      created_at INTEGER NOT NULL
    )`,
  });

  const applied = await client.query({
    databaseId,
    statement:
      'SELECT id, hash, created_at FROM __drizzle_migrations ORDER BY created_at DESC LIMIT 1',
  });
  const lastAppliedTimestamp =
    applied.rows.length > 0 ? Number(applied.rows[0][2]) : 0;

  for (const migration of migrationEntries) {
    if (migration.folderMillis <= lastAppliedTimestamp) {
      continue;
    }
    await client.beginTransaction({ databaseId });
    try {
      for (const sql of migration.sql) {
        await client.execute({ databaseId, statement: sql });
      }
      await client.execute({
        databaseId,
        statement:
          'INSERT INTO __drizzle_migrations (hash, created_at) VALUES (?, ?)',
        values: ['', migration.folderMillis],
      });
      await client.commitTransaction({ databaseId });
    } catch (error) {
      await client.rollbackTransaction({ databaseId });
      throw error;
    }
  }
}

function readMigrationFiles(
  config: Migrations,
): { sql: string[]; folderMillis: number }[] {
  const entries: { sql: string[]; folderMillis: number }[] = [];

  for (const entry of config.journal.entries) {
    const key = `m${entry.idx.toString().padStart(4, '0')}`;
    const query = config.migrations[key];
    if (!query) {
      throw new Error(`Missing migration: ${entry.tag}`);
    }
    entries.push({
      sql: query.split('--> statement-breakpoint'),
      folderMillis: entry.when,
    });
  }

  return entries;
}

async function executeQuery(
  client: SqlitePlugin,
  databaseId: string,
  sql: string,
  params: unknown[],
  method: 'run' | 'all' | 'values' | 'get',
): Promise<{ rows: unknown[] }> {
  const values = params as Value[];

  if (method === 'run') {
    const result = await client.execute({
      databaseId,
      statement: sql,
      values,
    });
    return {
      rows: [{ changes: result.changes, lastInsertRowid: result.rowId }],
    };
  }

  const result = await client.query({
    databaseId,
    statement: sql,
    values,
  });

  if (method === 'get') {
    return { rows: result.rows[0] ?? [] };
  }

  return { rows: result.rows };
}
